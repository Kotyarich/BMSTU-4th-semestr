class Complex {
	private:
		double re, im;
	public:
		Complex();
		Complex(double r)
		Complex(double r, doubl i)
		// useless
		Complex(const Complex & c)

};

Ways to create object:
Complex f(), function
--//--- a,   object/variable (1st constuctor)
--//--- b = Complex(1.),
--//--- b2(2.)
--//--- b3 = 3.,
--//--- b4 = {4.} / b4{5.}


Отключить приведение типов
class A {
	public:
		void f(int);
		void f(double) = deleted;
}
Отключается приведение типов в принципе


Семантика перемещения

Vector & operator=(const Vector & v) {
	delete []arr;
	count = v.count;
	arr = new double[count];
	for (int i = 0; i < count; i++) {
		arr[i] = v.arr[i];
	}
}

Vector & operator=(Vector && v) {
	delete []arr;
	count = v.count;
	arr = v.arr;
	v.arr = nullptr; // for destructor of v object, to not free copied memory
}

Для конструкторов аналогично, но delete []arr не нужны
Повторяющийся код вынести в приватный метод

Обработка исключительных ситуаций

Для ошибок класса Vector создается базовый класс исключений VectorException от
которого будут наследоваться более конкретные классы исключений

Ошибка должна содержать время, дата, метод, класс, причину (слепок параметров)

class MyExeption: public std::exception {
 public:
  virtual const char* what() const noexcept;
  --//--                           throw(<type>) // метод не может генерить ошибки типа type
}

Шаблоны

template<typename T, size_t n>
class Vector {
 private:
	T arr[n];
	size_t size = n;
 public:
	Vector();
	count();
}


Creation: Vector<double, 100> v;
----------------------------------------------------------
Частичная специализация шаблона, специализации
template <typename T1, typename t2>
class A{};
template <typename T>
class A<T, T> {};
template <typename T>
class A<T, int> {};
template <typename T1, typename T2>
class A<T*, T*> {};

A<float, foat> a1;
A<int, float> a2;
A<float, int> a3;
A<int *, float *> a4;
A<int, int> a5;
A<int *, int *> a6;

умные указатели


----------------------------------------------------------------------
> 50 классов в домене - плохо => домен разбивается на подсистемы

- Схема доменов
- Проектная матрица
Если домен разбивается на подсистемы:
- Модель связей подсистем
- Модель взаимодействия
- Модель доступа
Для каждой подсистемы:
- Информационная модель
- Описание классов и атрибутов
- Описание связей
- Модель взаимодействия объектов
- Список событий
- Модель доступа к объекту
- Таблица процессов состояний
Для каждого класса:
- Модель состояний
- Диаграмма потоков данных, действий
Для каждого процесса:
- Описание процесса

 _____________________________________________________________
|Номер класса	Имя класса	Ключевой литерал (1-2 символа)|
--------------------------------------------------------------|
|*(привелигерованный атрибут)				      |
|-							      |
|-							      |
...
|-							      |
|-------------------------------------------------------------|

Атрибуты бывают:
- идентифицирующими (идендификатор или его часть)
- описательные - абстрагирует какую-либо характеристику
- вспомогательные - используется для формализации связи, может быть атрибутом состояния

Правила атрибутов:
1.  Для объекта все атрибуты должны иметь значение, если значение не определено, то это
    объект другого класса;
    На этапе инфомрационного моделирования нужно определить значения всех атрибутов
2.  При ООА атрибут должен быть простым, иначе это отдельная сущность и нужо формализовывать связь
3.  Если объект имеет составной идентификатор, то любой атрибут, являющийся частью идентификатора
    представляет характеристику всего объекта, а не его части

Пример:

1. Преподаватель 
* ФИО
- Кафедра
- Звание ????
- Должность 

Связи существуют всегда
Связи делятся на:
1. Связь 1 к 1, (муж - жена), нужно выделить главным и добавить к нему вспомогательный атрибут
2. Многие ко многим (студенты - учебные курсы), добавляется новая ассоциативная связь
3. 1 ко многим, можно добавить многим вспомогательный атрибут (студенту ФИО препода, связь (R1))


Выполнить ООА для домена
Выделить сущности, их аттрибуты, определить связи между сущностями
т.е. выполнить информационное моделирование - построить диаграмму сущность-связь.
Выделить сущности с четко выделенным поведением, сформировать их жизненный цикл,
использовать диаграмму ДПС (перехода состояний)
Для контроля корректности формирования жизненного цикла - ТПС (таблица переходов состояний)
Проанализировать взаимодействие с окружающим миром - строится МВО (модель взаимодействия объектов)
Проверить корректность МВО (насколько правильно выбраны модели состояний, синхронизируются
жизенные циклы) - выполнить имитирование процесса. Это долго и муторно
Нужно выделить внешние незапрашиваемые события и для каждого из них выполнить канал управления,
причем для всевозможных начальных состояний
Нарисовать хотя бы 1 канал управления
ДПДД (диагр. потоков данных, действий) - сделать 2-3
Если есть пассивыне объекты - диаграмма доступа к объектам

Любой бытовой прибор (стиральная машина, микроволновка)

Домен - отдельный реальный/гипотетический мир населенный тчетливым нарром объектов, которые
ведут себя в соответствии с характерными для домена правилами и линиями поведения

Прикладной домен: 
Архитектурный домен: задает этап обработки, архитектуру системы
реализуется модель (событийная), представляет собой набор таймеров разных видов
Сервисные домены: набор сервисных функций
Домен реализации: подразумевает функциал, предоставляемый низким уровнем (сеть, функционал ОС)

Диаграма связей подсистем

В прямоугольнике имя подсистемы и номера классов (не более 50)
Между прямоугольниками - линии (связи), рядом с ними перечисляются связи (R15, R17, e.t.c)

Модель взаимодействия подсистем (аналог МВО)
В прмоугольнике подсистема, между ними стрелки - события и пометить идентификаторы событий

Аксессорное взаимодействие - еще какая-то хуйня

Выделяются сервера и клиенты - представляющие свои возможности и использующие их
Сервисные, архитектурные домены - сервера
Прикладные - клиенты

От всего говна сверху нужно перейти к проектным документам, по которым удобно писать код.
Нотация Градигуч-Баха
Диаграмма класса, структура класса, диаграмма зависимостей и диаграмма наследований


Диаграмма класса

имя в прямоугольнике
аттрибуты - гробики

справа - методы класса
слева- методы объекта

метод принимает данные - гробик над линией
возвращает - под линией
на линии - изменияемы данные

ромб справа метода - исключение
коллбек вызовы - слева прямоугольника метода ставится вертикальная черта
асинхронно вызываемые обработчики состояний, асинк методы - пунктирной линией
внутренние методы не рисуются


схема структуры класса - цель этой хуйни - проконтролировать все потоки данных

вытянутый шестиугольник - объект, архив данных
сверху прямоугольники - методы, представляющие интерфейс
они принимают данные из-вне
под ними идут внутренние методы 
гробик: стрелка вверх - возвращаемое даное, вниз - передаваемое данное

5угольник - внешние данные, к ним могут обращаться методы

Методы интерфейса должны по мнимуму вызывать другие методы интерфейса
